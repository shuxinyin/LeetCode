## 字符串

[剑指 Offer 17]打印从1到最大的n位数

[剑指 Offer 19]正则表达式匹配
[剑指 Offer 20]表示数值的字符串

[剑指 Offer 43]1～n 整数中 1 出现的次数
[剑指 Offer 44]数字序列中某一位的数字
[剑指 Offer 49]丑数
[剑指 Offer 51]数组中的逆序对

[剑指 Offer 59 - II]队列的最大值
[剑指 Offer 59 - I]滑动窗口的最大值
[剑指 Offer 60]n个骰子的点数


#### ??[剑指 Offer 67]把字符串转换成整数

Q: 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 
    注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 

> 输入: "   -42"
> 输出: -42
> 解释: 第一个非空白字符为 '-', 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。

> 输入: "4193 with words"
> 输出: 4193
> 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```python
class Solution:
    def StrToInt(self, s):
            Sum = 0
            Sign = 1
            s = s.strip()
            for i,num in enumerate(s):
                if i == 0:
                    if s[i] == '+':
                        continue
                    elif s[i] == '-':
                        Sign = -1
                        continue
                if num >= '0' and num <= '9':
                    Sum = Sum * 10 + int(s[i])
                else:
                    return 0
            
            return Sign * Sum

```

#### [剑指 Offer 17]打印从1到最大的n位数

Q: 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 
> 输入: n = 1
> 输出: [1,2,3,4,5,6,7,8,9]

```python
class Solution:
    def printNumbers(self, n: int) -> List[int]:
        res = []
        for i in range(1, 10 ** n):
            res.append(i)
        return res

```

#### [剑指 Offer 19]正则表达式匹配

Q: 请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。
在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。 

> s = "aa"
> p = "a"
> 输出: false
> 解释: "a" 无法匹配 "aa" 整个字符串。

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        ''' 采用递归的方法来实现。
            递归结束的条件是：当p结束的时候s也结束，则返回true；p结束的时候s没结束，返回False。
            在判断的过程中有两种情况，
            一种是p[1]为"*"，此时有两种可能:
                1.匹配零个p[0](下一步为match[s,p[2:]])
                2. 匹配多个p[0](这一步需要判断s[0]和p[0]是否匹配下一步为match(s[1:],p)，
            第二种p[1]不为"*"：
                只需要判断s[0]和p[0]是否匹配并且下一步为match(s[1:],p[1:])即可，s[0]和p[0]匹配的情况是s[0]==p[0]或者p[0]为“.”
        '''
        if not p:   
            return not s

        # p 与 s 头个字符能否匹配上
        first_match = (len(s)>0 and (s[0]==p[0] or p[0]=='.'))
        if len(p)>=2 and p[1]=='*':
            return self.isMatch(s,p[2:]) or (first_match and self.isMatch(s[1:],p))
        else:
            return first_match and self.isMatch(s[1:],p[1:])

```

#### [剑指 Offer 20]表示数值的字符串
Q: 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 


> 输入：s = "    .1  "
> 输出：true

```python
class Solution:
    def isNumber(self, s: str) -> bool:
        ''' 有限状态机
        '''
        pass

```

#### ??[剑指 Offer 43]1～n 整数中 1 出现的次数
Q:  输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 
    例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 

>  输入：n = 12
>  输出：5

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        '''
            一个数字可以看做是 高位+当前位+低位
        '''
        pass
```


#### [剑指 Offer 44]数字序列中某一位的数字

Q: 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4等等。

> 输入：n = 3
> 输出：3

```python
class Solution:
    def findNthDigit(self, n: int) -> int:
        ''' 找规律
        1.确定这个n位在几位数字中.
        2.确定这个n位在几位数字中的那一个数字中.
        3.确定这个n位在几位数字中的那一个数字中的那一位.
        '''
        # 位数， 起始数字， 数位
        digit, start, count = 1, 1, 9
        
        # 1. 确定n位在 几位数中
        while n>count:
            n -= count
            start *= 10
            digit += 1
            count = 9 * start * digit
        # 2. 确定n位在几位数字中的哪一个数字中
        num = start + (n-1)//digit
        return int(str(num)[(n-1) % digit])
```


#### [剑指 Offer 49]丑数
Q: 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 

> 输入: n = 10
> 输出: 12
> 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 

```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        ''' 丑数 从小到大 依次递进
        '''
        dp = [1] * n
        a, b, c, = 0, 0, 0

        for i in range(1, n):
            n2, n3, n5 = dp[a] * 2, dp[b] * 3, dp[c] * 5
            dp[i] = min(n2, n3, n5)

            if dp[i] == n2:
                a += 1
            if dp[i] == n3:
                b += 1
            if dp[i] == n5:
                c += 1
        return dp[-1]
```
#### [剑指 Offer 51]数组中的逆序对

Q: 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 

> 输入: [7,5,6,4]
> 输出: 5 

```python
class Solution:
    def merge(self, left_nums, right_nums):
        res = []
        i, j = 0, 0
        while i < len(left_nums) and j < len(right_nums):
            if left_nums[i] <= right_nums[j]:
                res.append(left_nums[i])
                i += 1
            else:
                res.append(right_nums[j])
                # 有 len(left_nums) - i个数，与right[j]构成逆序对
                self.count += len(left_nums) - i  
                j += 1

        if i == len(left_nums):
            res += right_nums[j:]
        else:
            res += left_nums[i:]
        return res

    def merge_sort(self, nums):
        length = len(nums)
        if length <= 1:
            return nums

        mid = length // 2
        left_nums = self.merge_sort(nums[:mid])
        right_nums = self.merge_sort(nums[mid:])

        return self.merge(left_nums, right_nums)

    def reversePairs(self, nums: [int]) -> int:
        ''' merge sort
        '''
        self.count = 0
        self.merge_sort(nums)
        return self.count

```

#### [剑指 Offer 59 - I]滑动窗口的最大值
Q: 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 

> 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
> 输出: [3,3,5,5,6,7] 

>  滑动窗口的位置                最大值
> [1  3  -1] -3  5  3  6  7       3
>  1 [3  -1  -3] 5  3  6  7       3
>  1  3 [-1  -3  5] 3  6  7       5
>  1  3  -1 [-3  5  3] 6  7       5
>  1  3  -1  -3 [5  3  6] 7       6
>  1  3  -1  -3  5 [3  6  7]      7 

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ''' 双端队列deque
            首先保持队列deque长度为3， 头部是最大的元素， 其余放尾部
            新来一个元素， 比头部大的时候， 清空deque, 更新头， 其余popright
        '''
        import collections
        if not nums or k == 0: return []
        deque = collections.deque()
        # 未形成窗口
        for i in range(k):
            # 创建窗口，保持头部元素最大
            while deque and deque[-1] < nums[i]:
                deque.pop()
            deque.append(nums[i])

        res = [deque[0]]
        for i in range(k, len(nums)):
            # 此时说明首位已经不在窗口中了，需pop
            if deque[0] == nums[i - k]:
                deque.popleft()

            # 队列尾部元素 < nums[i], popright
            while deque and deque[-1] < nums[i]:
                deque.pop()
            deque.append(nums[i])
            res.append(deque[0])
        return res

```


#### [剑指 Offer 59 - II]队列的最大值
Q: 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 
    若队列为空，pop_front 和 max_value 需要返回 -1 
```python
class MaxQueue:

    def __init__(self):


    def max_value(self) -> int:


    def push_back(self, value: int) -> None:


    def pop_front(self) -> int:


```

    
#### [剑指 Offer 60]n个骰子的点数
Q: 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
    你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 
>  输入: 2
>  输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] 


```python
class Solution:

    def dicesProbability(self, n: int) -> List[float]:
        '''DP: n个骰子 点数区间 [n, 6n] 
        思路：假设f(m,n)表示投第m个骰子的时候，点数之和为n出现的次数，投第m个骰子的点数之和只与投第m-1个骰子有关。
            逆向 递归方程： f(m,n)=f(m-1,n-1)+f(m-1,n-2)+f(m-1,n-3)+f(m-1,n-4)+f(m-1,n-5)+f(m-1,n-6)
            正向 递归方程：由于新增骰子的点数只可能为 1 至 6 ，因此概率 f(n−1,x) 仅与贡献 f(n,x+1), f(n,x+2), ... , f(n,x+6) 相关
            
        由于只与上一轮骰子数有关，采用一维数组。
        递归方程： f(n)=f(n-1)+f(n-2)+f(n-3)+f(n-4)+f(n-5)+f(n-6)
        
        Time: O(n^2)
        Space: O(n)
        '''
        
        dp = [1 / 6] * 6  # 1个骰子
        for i in range(2, n + 1):  # 第2个~n个骰子

            # 点数之和的值最大是i*6，最小是i*1, i之前的结果值是不会出现的；
            #如i=3个骰子时，最小就是3了，不可能是2和1，所以点数之和的值的个数是6*i-(i-1)，化简：5*i+1
            tmp_dp = [0] * (5 * i + 1) 

            for j in range(len(dp)):  # 正向推导
                for k in range(6):  # n-1中每一个j都对n中6个值会有贡献
                    tmp_dp[j + k] += dp[j] / 6
            dp = tmp_dp  # 更新现有状态n-1 到 n个骰子， 用于计算n+1个骰子
        return dp

```

  
#### [剑指 Offer 67]把字符串转换成整数
Q: 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 
    注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 
    在任何情况下，若函数不能进行有效的转换时，请返回 0。 
    假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2³¹, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231− 1) 或 INT_MIN (−2³¹) 。 

> 输入: "4193 with words"
> 输出: 4193
> 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。

```python
class Solution:
    def strToInt(self, str: str) -> int:
        str = str.strip()                      # 删除首尾空格
        if not str: return 0                   # 字符串为空则直接返回
        res, i, sign = 0, 1, 1
        int_max, int_min, bndry = 2 ** 31 - 1, -2 ** 31, 2 ** 31 // 10
        if str[0] == '-': sign = -1            # 保存负号
        elif str[0] != '+': i = 0              # 若无符号位，则需从 i = 0 开始数字拼接
        for c in str[i:]:
            if not '0' <= c <= '9' : break     # 遇到非数字的字符则跳出
            if res > bndry or res == bndry and c > '7': return int_max if sign == 1 else int_min # 数字越界处理
            res = 10 * res + ord(c) - ord('0') # 数字拼接
        return sign * res


```
### 卡特兰数 + 数组 + 字符串