## 二叉树

### 二叉树的遍历

1. 前序遍历
```python
class Solution:
    def __init__(self):
        self.res = []
    def preOrder(self, root):
        if not root:
            return 
        self.res.append(root.val)
        self.preOrder(root.left)
        self.preOrder(root.right)

```

2. 中序遍历
```python
class Solution:
    def __init__(self):
        self.res = []
    def inOrder(self, root):
        if not root:
            return 
        self.preOrder(root.left)
        self.res.append(root.val)
        self.preOrder(root.right)

```

3. 后序遍历
```python
class Solution:
    def __init__(self):
        self.res = []
    def postOrder(self, root):
        if not root:
            return 
        self.preOrder(root.left)
        self.preOrder(root.right)
        self.res.append(root.val)
```


4. 层序遍历
剑指 Offer 32 - I. 从上到下打印二叉树
剑指 Offer 32 - II. 从上到下打印二叉树 II
剑指 Offer 32 - III. 从上到下打印二叉树 III

sword4offer: 32_I、32_II、32_III 二叉树的打印
```python
class Solution:
    def levelOrder(self, root):
        import collections
        if not root:
            return []
        
        res = []
        queue = collections.deque()
        queue.append(root)
        while queue:
            node = queue.popleft()
            res.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return res            

```

### 二叉树的子树、镜像问题
剑指 Offer 26. 树的子结构
剑指 Offer 27. 二叉树的镜像
剑指 Offer 28. 对称的二叉树

1. 子树
```python
class Solution:
    def isSubStructure(self, A, B) -> bool:
        def recur(A, B):
            if not B:
                return True
            if not A or A.val != B.val:
                return False

            return recur(A.left, B.left) and recur(A.right, B.right)

        return bool(A and B) and (recur(A, B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B))

```
2. 对称的二叉树
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def recur(L, R):
            # 左右都为None, 表明到叶子节点了
            if not L and not R:
                return True
            if not L or not R or L.val != R.val:
                return False

            return recur(L.left, R.right) and recur(L.right, R.left)

        return recur(root.left, root.right) if root else True
```
3. 二叉树的镜像
```python
class Solution:
    def mirrorTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return

        tmp = root.left
        root.left = self.mirrorTree(root.right)
        root.right = self.mirrorTree(tmp)

        return root
```


### 二叉树问题

剑指 Offer 34. 二叉树中和为某一值的路径
剑指 Offer 36. 二叉搜索树与双向链表
剑指 Offer 54. 二叉搜索树的第k大节点

剑指 Offer 55 - I. 二叉树的深度
剑指 Offer 55 - II. 平衡二叉树

剑指 Offer 64. 求1+2+…+n
剑指 Offer 68 - I. 二叉搜索树的最近公共祖先
剑指 Offer 68 - II. 二叉树的最近公共祖先

剑指 Offer 07. 重建二叉树
剑指 Offer 16. 数值的整数次方
剑指 Offer 33. 二叉搜索树的后序遍历序列

剑指 Offer 37. 序列化二叉树
剑指 Offer 38. 字符串的排列