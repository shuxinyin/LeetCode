# 贪心算法
建议刷完以下所有题目后，熟悉题目后，再来看这份总结，效果更佳。

### 文档使用方法：

1.首先可以根据刷题脑图顺序刷题。

2.其次若是遇见题目无思路的情况然后可以根据这份文档提供的参考思路继续做题，

3.再之可以参考的GitHub项目对应专题problem文件夹相应参考代码、solution文件夹具体解题讲解。以上均收集于leetcode最优解思路及自己解题思路。

4.最后可利用此总结文档，对照题目，再重复刷一遍，效果极佳，欢迎点赞尝试

## 贪心算法思想上
「贪心算法」 和 「动态规划」、「回溯搜索」 算法一样，完成一件事情，是 分步决策 的；  
「贪心算法」的分布决策在每一步总是做出在当前看来最好的选择，我是这样理解 「最好」 这两个字的意思：  
「最好」 的意思往往根据题目而来，可能是 「最小」，也可能是 「最大」；
「贪心算法」 基本思路是：需要先制定一个规则，然后在符合当前规则下，取当前最好的选择。所以为满足规则，方便决策，
往往需要做一些预备工作，比如排序，统计频次等 （**难点就是制定符合题目需要的规则**）  
**贪心算法和动态规划相比，它既不看前面（也就是说它不需要从前面的状态转移过来），也不看后面（无后效性，后面的选择不会对前面的选择有影响）**，  
因此贪心算法时间复杂度一般是线性的，空间复杂度是常数级别的；

**附带一个不常规可尝试套路**：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。  

## 贪心算法涉及的各题目总结

### 分配问题：

#### 455.分发饼干
问题：

> 例子：分饼干，child胃口序列g = [1,2,3]，饼干尺寸序列s = [1,1]，若饼干s[j]>=胃口g[i]，则孩子得到满足，最多满足几个小孩

解题规则制定：

>        贪心思想： 从胃口最小的小孩子满足起，分配最小且能满足胃口的饼干，则每一步都是最好的安排。
>
>        1. child胃口升序排列，饼干尺寸升序排序
>
>        2. 采用两个index，ind1标记g，ind2标记s 
>
>        3. 同步遍历胃口、饼干序列：若是当前饼干满足不了当前胃口最小的小孩，则也满足不了后面的小孩，则跳到下一块。（while 做一个判断循环即可，此处不要第一想法想着用for循环）

#### 135.分发糖果
问题：

>例子：一个孩子分数序列s=[1,0,2], 但评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果,问要准备几颗糖果c。
>
>例子：s = [1,2,2], c=4 （可以分别给这三个孩子分发 1、2、1 颗糖果）

解题规则制定：


>A: 规则定义： 设学生 A 和学生 B 左右相邻，A 在 B 左边； 
    左规则： 当 ratingsB > ratingsA时，B 的糖比 A 的糖数量多。 
    右规则： 当 ratingsA > ratingsB时，A 的糖比 B 的糖数量多。 
    相邻的学生中，评分高的学生必须获得更多的糖果 等价于 所有学生满足左规则且满足右规则。
    解决方法： 遍历两遍，
            第一遍：从左至右边遍历，满足左规则, 结果存于left_list 
            第二遍：从右往左遍历， 满足右规则, 结果存于right_list 
            遍历： count += max(left, right) 

### 区间问题

#### 435.无重叠区间

问题：

> 例子：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 
>
> 输入: [ [1,2], [2,3], [3,4], [1,3] ]
>
> 输出: 1 
>
> 解释: 移除 [1,3] 后，剩下的区间没有重叠

解题规则制定：

>        首先要对区间进行排序，这里先以区间的头来排序，然后在遍历区间。
>        1，如果后面区间的头小于当前区间的尾，
>              比如当前区间是[3,6]，后面区间是[4,5]或者是[5,9],说明这两个区间有重复，必须要移除一个，那么要移除哪个呢?
>              为了防止在下一个区间和现有区间有重叠，我们应该让现有区间越短越好，所以应该移除尾部比较大的，保留尾部比较小的。(故移除[3,6],[5,9])
>
>        2，如果后面区间的头不小于当前区间的尾，说明他们没有重合，不需要移除

#### 452.用最少数量的箭引爆气球

问题：

> 气球尺寸序列points = [[10,16],[2,8],[1,6],[7,12]]，其中points [i] = [xstart,xend]（尺寸为x轴坐标），从x轴射出，至少需要几支箭可以射爆所以气球。
>
> 输入：points = [[10,16],[2,8],[1,6],[7,12]]
>
> 输出：2
>
> 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球

解题规则制定：

>        与435类似，但有不同点: 这里需要右排序
>              首先要对区间进行排序，这里先以区间的尾来排序（右排序），然后在遍历区间。
>              1，箭从第一个区间尾射出，如果后面区间的头小于等于当前区间的尾
>              比如当前区间是[4,5]，后面区间是[3,6]或者是[5,9]
>              说明这两个区间有重复，则箭可以贯穿，
>              2，如果后面区间的头大于当前区间的尾，说明他们没有重合，箭+1，从这个区间尾射出

#### 602.种花问题

问题：

> 一条花坛（尺寸1*N），一部分地块种植了花，另一部分却没有，另外花不能种植在相邻的位置上。问在花坛flowerbed = [1,0,0,0,1]，还能种下n朵花吗？
>
> 输入：flowerbed = [1,0,0,0,1], n = 1
>
> 输出：true

解题规则制定：

>        两格连跳方法：因为如果遇到1,那么下一格子一定是0，这是毋庸置疑的（规则限定：花儿不能相邻。**体会这个暗含规则**）
>         所以如果遇到当前位置i为最后一个格子，或者i的下个格子不是1，果断种花填充。

#### 763.划分字母区间

问题：

> 一个字母序列s="ababcbacadefegdehijhklij", 划分为多个片段，要求同一字母最多出现在一个片段中，返回每个片段的长度。
>
> 输入：S = "ababcbacadefegdehijhklij"
>
> 输出：[9,7,8]    解释：划分结果为 "ababcbaca", "defegde", "hijhklij"。

解题规则制定：

>        1， 首先看第一个字母，找到它在串里最后的一个位置，记作last或一段的最后位置。
>        2， 在从0~last这个范围里，挨个查其他字母，看他们的最后位置是不是比刚才的last或这一段的最后位置大。
>            如果没有刚才的last或一段的最后位置大，无视它继续往后找。
>            如果比刚才的大，说明这一段的分隔位置必须往后移动，所以我们把last或这一段的最后位置更新为当前的字母的最后位置。
>        3，肯定到有一个时间（即左边搜索的index==last_index），这个last就更新不了了，那么这个时候这个位置就是我们的分隔位置。
>            注意题目要分隔后的长度，我们就用last - start_index + 1。
>        4，找到一个分割位，更新一下起始位置，同理搜索就行了。

#### 122.买卖股票的最佳时机II中：

问题：

> 例子:给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。当天你可以尽可能地完成更多的交易（多次买卖一支股票），怎样获取最大利润。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 
>
> 输入: prices = [7,1,5,3,6,4]
>
> 输出: 7
>
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3

解题规则制定：

> 这道题 「贪心」 的地方关键在于，对于 「今天股价-昨天股价」，得到的结果有 3 种可能：① 正数，② 0，③负数。
> 贪心算法的决策规则是： 只加正数。最后加上差值中所有正数，即为最大利差。  

#### 406.根据身高重建队列

问题：

> 一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面正好有ki个身高大于或等于 hi 的人。 但这个队列打乱了，怎么复原它？
>
> 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
>
> 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

解题规则制定：

> 规则： 先按照身高h降序排序(身高相同则按K值升序)，然后再按照k值重新插入。

#### 665.非递减数列

问题：

> 给你一个长度为 n 的整数数组，请你判断在最多改变1个元素的情况下，该数组能否变成一个非递减数列。 
>
> 输入: nums = [4,2,3]
>
> 输出: true

解题规则制定：

> 当 nums[i] 破坏了数组的单调递增时，即 nums[i] < nums[i - 1] 时，为了让数组有序，我们发现一个规律（记住【4，2，5】, 【1，4，2，5】,【3，4，2，5】这三个特殊情况，则这题易解）：
>
> 1, 如例【4，2，5】的情况，当 i = 1 ，那么修改 num[i- 1] ，不要动 nums[i] ，因为nums[i]后面的元素是啥我们还不知道呢，少动它为妙。
>
> 2, 如例【1，4，2，5】的情况，当 i > 1 时，我们应该优先考虑把 nums[i - 1] 调小到 >= nums[i - 2] 并且 <= nums[i]。同样尽量不去修改 nums[i] ，理由同上。
>
> 3, 如例【3，4，2，5】的情况，当 i > 1 且 nums[i] < nums[i - 2] 时，我们无法调整 nums[i - 1] ，我们只能调整 nums[i] 到 nums[i - 1] 。
