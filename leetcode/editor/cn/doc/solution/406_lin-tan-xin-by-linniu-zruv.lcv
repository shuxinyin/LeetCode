### 解题思路

**和分发糖果一样，要先确定一个维度。我们这里选取的维度就是高度。**
先按照高度进行排序，从大到小
如果高度相同就按照k去排序，从小到大。

后面只需要把排好序的people数组依次插入队列queue就行，插入的下标由k决定。
因为后来插入队列的身高，都是比队列中的身高小，所以不会对队列中已存在的k产生影响。

排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]

插入的过程：
① 插入[7,0]：[[7,0]]
② 插入[7,1]：[[7,0],[7,1]]
③ 插入[6,1]：[[7,0],[6,1],[7,1]]
④ 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]
⑤ 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]
⑥ 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

### 代码

* java

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,(a,b) ->{
            // 如果身高相同，k就按从小到大排序 [7,0],[7,1]
            if(a[0] == b[0]) return a[1] - b[1];
            
            // 身高从大到小
            return b[0] - a[0];

        });

        LinkedList<int[]> queue = new LinkedList<>();
        for(int[] array : people){
            queue.add(array[1],array);
        }


        return queue.toArray(new int[people.length][]);
    }
}
```

